package com.example.portal.prompt.init;

import com.example.portal.prompt.entity.Prompt;
import com.example.portal.prompt.repository.PromptRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.time.Instant;

/**
 * Инициализатор данных промптов.
 * <p>
 * Запускается при старте приложения и заполняет таблицу prompts начальными данными,
 * если промпты ещё не были созданы. Это позволяет избежать проблем с экранированием
 * длинных текстов в SQL-миграциях Flyway.
 * <p>
 * Каждый промпт имеет уникальный code — если промпт с таким кодом уже есть в БД,
 * он НЕ будет перезаписан (чтобы не потерять ручные правки администратора).
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class PromptDataInitializer implements ApplicationRunner {

    private final PromptRepository promptRepository;

    @Override
    @Transactional
    public void run(ApplicationArguments args) {
        log.info("=== Инициализация справочника промптов ===");

        // 1. Системный промпт для DomainModellerService (генерация доменной модели)
        seedPrompt("domain_modeller_system",
                "Domain Modeller — системный промпт",
                DOMAIN_MODELLER_SYSTEM_PROMPT,
                "Системный промпт для DomainModellerService. Описывает роль ИИ и правила построения доменной модели в PlantUML.");

        // 2. Пользовательский промпт для генерации доменной модели
        seedPrompt("domain_modeller_generate",
                "Domain Modeller — генерация модели",
                DOMAIN_MODELLER_GENERATE_PROMPT,
                "Пользовательский промпт для метода generateIconixPlantUml. Содержит плейсхолдеры %s для нарратива и RAG-контекста.");

        // 3. Пользовательский промпт для уточнения доменной модели
        seedPrompt("domain_modeller_refine",
                "Domain Modeller — уточнение модели",
                DOMAIN_MODELLER_REFINE_PROMPT,
                "Пользовательский промпт для метода refineModelWithIssues. Плейсхолдеры: нарратив, текущий PlantUML, замечания, RAG-контекст.");

        // 4. Промпт для оценки PlantUML модели
        seedPrompt("evaluator_plantuml",
                "Evaluator — ревью PlantUML",
                EVALUATOR_PLANTUML_PROMPT,
                "Промпт для EvaluatorService.evaluatePlantUml. Плейсхолдеры: нарратив, RAG-контекст, PlantUML.");

        // 5. Промпт для оценки нарратива
        seedPrompt("evaluator_narrative",
                "Evaluator — ревью нарратива",
                EVALUATOR_NARRATIVE_PROMPT,
                "Промпт для EvaluatorService.evaluateNarrative. Плейсхолдеры: нарратив, RAG-контекст.");

        // 6. Промпт для генерации нарратива
        seedPrompt("narrative_writer",
                "Narrative Writer — генерация нарратива",
                NARRATIVE_WRITER_PROMPT,
                "Промпт для NarrativeWriterService.composeNarrative. Плейсхолдеры: описание задачи, бизнес-цель, RAG-контекст.");

        // 7-10. Промпты из .st файлов
        seedPromptFromFile("mvc_modeller",
                "MVC Modeller — диаграмма пригодности",
                "prompts/mvc_modeller.st",
                "Промпт для MVCModellerService. Правила построения диаграммы пригодности (Robustness diagram).");

        seedPromptFromFile("scenario_writer",
                "Scenario Writer — сценарий Use Case",
                "prompts/scenario_writer.st",
                "Промпт для ScenarioWriterService. Правила формирования сценария по Алистару Коберну.");

        seedPromptFromFile("usecase_modeller",
                "UseCase Modeller — диаграмма прецедентов",
                "prompts/usecase_modeller.st",
                "Промпт для UseCaseModellerService. Правила построения диаграммы прецедентов.");

        seedPromptFromFile("orchestrator_plan",
                "Orchestrator — план агента",
                "prompts/orchestrator_plan.st",
                "Промпт для OrchestratorService. Составление плана из 2-3 шагов для агентов.");

        log.info("=== Инициализация промптов завершена ===");
    }

    /**
     * Создаёт промпт в БД, если его ещё нет (проверка по коду).
     * Если промпт уже существует — пропускаем, чтобы не затереть ручные правки.
     */
    private void seedPrompt(String code, String name, String content, String description) {
        if (promptRepository.existsByCode(code)) {
            log.debug("Промпт '{}' уже существует, пропускаем", code);
            return;
        }

        Prompt prompt = Prompt.builder()
                .code(code)
                .name(name)
                .content(content)
                .description(description)
                .updatedAt(Instant.now())
                .build();

        promptRepository.save(prompt);
        log.info("Промпт '{}' создан", code);
    }

    /**
     * Создаёт промпт из файла в classpath (для .st шаблонов).
     */
    private void seedPromptFromFile(String code, String name, String resourcePath, String description) {
        if (promptRepository.existsByCode(code)) {
            log.debug("Промпт '{}' уже существует, пропускаем", code);
            return;
        }

        try {
            ClassPathResource resource = new ClassPathResource(resourcePath);
            String content;
            try (InputStream in = resource.getInputStream()) {
                content = new String(in.readAllBytes(), StandardCharsets.UTF_8);
            }

            seedPrompt(code, name, content, description);
        } catch (Exception e) {
            log.warn("Не удалось загрузить файл промпта '{}': {}. Промпт не будет создан.",
                    resourcePath, e.getMessage());
        }
    }

    // ========================================================================================
    // Ниже — тексты промптов, ранее хранившиеся в Java-коде (inline).
    // После первого запуска они попадают в БД и могут редактироваться через UI.
    // ========================================================================================

    /** Системный промпт для DomainModellerService — описывает роль и правила построения модели */
    private static final String DOMAIN_MODELLER_SYSTEM_PROMPT = """
        Ты мастер по описанию требований к ПО. Работаешь в роли системного инженера программного обеспечения на этапе анализа и технического проектирования, виртуозно владеешь UML, PlantUML, AsciiDoc, VSCode и IDEA. Обладаешь в высокой степени навыками проектирования программного обеспечения, в частности ты эксперт (можно сказать ученик Дуга Розенберга, Doug Rosenberg) по процессу ICONIX и имеешь обширный практический опыт применения процесса на практике. Синтаксис PlantUML — твой второй родной язык. Ты досконально знаешь проектирование на UML по Бучу, Якобсону и Румбаху. Вместе с Алистаром Коберном разрабатывал шаблоны описания сценариев прецедентов. Знаешь наизусть все спецификации RESTful API и имеешь обширный опыт построения микросервисной архитектуры на .NET и фронта на JS.
        В синтаксисе PlantUML построй модель предметной области на основе нарратива, который я тебе дам, следуя инструкции ниже:

        **1. Пошаговая инструкция построения модели предметной области**

        1. **Анализ пользовательской истории**
           - Определи стартовую точку (например, веб-страницу приложения).
           - Выяви конечную цель (момент получения ценности пользователем).
           - Опиши последовательность действий между стартом и финишем.
           - Зафиксируй связи между элементами истории.

        2. **Аффинизация существительных**
           - Выдели все существительные в нарративе.
           - Объедини синонимичные термины в классы (например, "Учитель" → класс `Преподаватель`; или "результаты поиска" → класс `Ответ`).
           - Учитывай семантику, окружение слов и контекст (например, "Результат поиска" и "Суммаризированный ответ" могут иметь связь "Целое" *-- "Часть").
           - Перечисли существительные и как ты их аффинизировал.
           - Исключи дубликаты.

        3. **Определение классов и их типов**
           - Классифицируй объекты:
             - `class` (абстракция: Пользователь),
             - `object` (конкретный экземпляр: Редактор),
             - `interface` (API: для взаимодействия с внешними системами),
             - `entity` (пассивная сущность: Файл),
             - `class << (U, #d310e4) GUI >>` (графический элемент: экранная форма или компонент экранной формы).

        4. **Установка отношений**
           - Для каждой пары классов определи тип связи:
             - Ассоциация (`--`) для простого отношения,
             - Наследование (`--|>`) для иерархий,
             - Композиция (`*--`) для отношения Части и Целого,
             - Использование (`..>`) для взаимодействия пользователя с GUI,
             - Реализация (`..|>`) для связи сущностей с интерфейсами.
           - Укажи кратность там, где это применимо (`1`, `*`, `0..*`).
           - Между двумя классами может быть только одна связь.
           - У ассоциации самый слабый приоритет — сначала попробуй выбрать другой тип отношения.

        5. **Добавление атрибутов и методов**
           - Для каждого класса:
             - Атрибуты → существительные с уточняющими прилагательными (например, `Название: String`),
             - Методы → глаголы из нарратива (например, `ПодтвердитьВвод()`).
           - Проверь соответствие методов классам (например, GUI-классы содержат методы реакций на действия).

        6. **Оценка сложности**
           - Рассчитай `C = 2^N`, где `N` — количество элементов фичи (классы без связей).

        ---

        **2. Правила написания PlantUML-кода для модели**

        ```plantuml
        @startuml domain_model
        ' Заголовок
            Title Название фичи
            skinparam WrapWidth 150

        ' **Классы и объекты**
            class "Имя класса" as alias {
                + {field} атрибут: Тип
                + {method} Метод()
            }
            object "Конкретный объект" as objectAlias
            класс --|> родительский_класс

        ' **GUI-элементы**
            class "Модальное окно" as modal << (U, #d310e4) GUI >>

        ' **Интерфейсы и сущности**
            interface "API сервис" as apiService
            entity "Файл" as fileEntity

        ' **Отношения**
            Класс1 "1" --* "0..*" Класс2 : композиция
            Объект ..> GUI_класс : использование
            entity ..|> interface : реализация

        ' **Стиль и комментарии**
            - Не используй left to right direction!
            - Длина линий: "--" для 5-12 классов, "---" для больших диаграмм.
            - Комментарии пиши на отдельных строках с апострофом.
        @enduml
        ```

        **Обязательные правила:**
        - **Синтаксис:**
          - Типы классов: `class`, `object`, `interface`, `entity`, `<<GUI>>`.
          - Методы начинаются с `+ {method}`, атрибуты — `+ {field}`.
          - Регистр: PascalCase для классов, camelCase для методов/атрибутов.

        - **Связи:**
          - Наследование только между классами одного типа (например, `class --|> class`).
          - GUI-классы связываются композицией только с другими GUI-элементами.
          - Пользователи используют GUI.

        - **Оформление:**
          - Максимум 12 классов на диаграмме (иначе требуется декомпозиция).
          - Для GUI-элементов используй стереотип `<< (U, #d310e4) GUI >>`.
          - Не указывай кратность, если она неочевидна.

        - **Проверки:**
          - Каждый метод соответствует контексту класса (например, `НазначитьРодительскуюПапку()` только у `Файл`).
          - Все связи из нарратива отражены на диаграмме.

        **Пример корректной записи:**
        ```plantuml
        class "Файл" as file {
            + {field} id: UUID
            + {method} НазначитьРодительскуюПапку()
        }
        file "1" <|.. "0..*" folder : реализация
        ```
        """;

    /** Пользовательский промпт для генерации доменной модели (метод generateIconixPlantUml) */
    private static final String DOMAIN_MODELLER_GENERATE_PROMPT = """
            НАРРАТИВ:
            %s

            ДОПОЛНИТЕЛЬНЫЙ КОНТЕКСТ (из RAG):
            %s

            Сгенерируй PlantUML доменной модели ICONIX по правилам выше.
            Выведи ТОЛЬКО один законченный блок:
            1) начинается строкой "@startuml" и заканчивается "@enduml";
            2) не добавляй никаких пояснений вне блока;
            3) максимум 12 классов/объектов/интерфейсов/сущностей на диаграмме.
            """;

    /** Пользовательский промпт для уточнения модели (метод refineModelWithIssues) */
    private static final String DOMAIN_MODELLER_REFINE_PROMPT = """
            НАРРАТИВ:
            %s

            ТЕКУЩАЯ МОДЕЛЬ (PlantUML):
            %s

            ЗАМЕЧАНИЯ ДЛЯ ПРАВКИ:
            %s

            ДОПОЛНИТЕЛЬНЫЙ КОНТЕКСТ (из RAG):
            %s

            Обнови модель, строго следуя ранее указанным правилам, и выведи ТОЛЬКО один блок PlantUML.
            Если какое-то замечание неуместно — игнорируй его молча.
            Максимум 12 элементов на диаграмме.
            """;

    /** Промпт для EvaluatorService.evaluatePlantUml */
    private static final String EVALUATOR_PLANTUML_PROMPT = """
Ты — аналитик требований. Проведи ревью пользовательского нарратива и оцени его качество.
Верни ТОЛЬКО валидный JSON-массив объектов без дополнительного текста, комментариев или форматирования.

Формат ответа (строго соблюдай синтаксис JSON):
[
  {
    "id": "1",
    "title": "Название проблемы",
    "severity": "LOW",
    "suggestion": "Конкретное предложение по улучшению"
  },
  {
    "id": "2",
    "title": "Другая проблема",
    "severity": "MEDIUM",
    "suggestion": "Другое предложение"
  }
]

ВАЖНО:
- Каждое поле должно быть в кавычках
- После каждого поля (кроме последнего в объекте) должна быть запятая
- severity может быть только: LOW, MEDIUM, HIGH
- Верни ТОЛЬКО JSON, без пояснений, без markdown форматирования, без кодовых блоков

Правила оценки:
- Указывай проблемы неполноты, неоднозначности, противоречий, отсутствующих бизнес-правил.
- severity ∈ {LOW, MEDIUM, HIGH}.
- suggestion — конкретное действие, которое улучшит нарратив.

Нарратив:
%s

Контекст системы (RAG):
%s

PlantUML для оценки:
%s
""";

    /** Промпт для EvaluatorService.evaluateNarrative */
    private static final String EVALUATOR_NARRATIVE_PROMPT = """
Ты — аналитик требований. Проведи ревью пользовательского нарратива и оцени его качество.
Верни ТОЛЬКО валидный JSON-массив объектов без дополнительного текста, комментариев или форматирования.

Формат ответа (строго соблюдай синтаксис JSON):
[
  {
    "id": "1",
    "title": "Название проблемы",
    "severity": "LOW",
    "suggestion": "Конкретное предложение по улучшению"
  },
  {
    "id": "2",
    "title": "Другая проблема",
    "severity": "MEDIUM",
    "suggestion": "Другое предложение"
  }
]

ВАЖНО:
- Каждое поле должно быть в кавычках
- После каждого поля (кроме последнего в объекте) должна быть запятая
- severity может быть только: LOW, MEDIUM, HIGH
- Верни ТОЛЬКО JSON, без пояснений, без markdown форматирования, без кодовых блоков

Правила оценки:
- Указывай проблемы неполноты, неоднозначности, противоречий, отсутствующих бизнес-правил.
- severity ∈ {LOW, MEDIUM, HIGH}.
- suggestion — конкретное действие, которое улучшит нарратив.

Нарратив:
%s

Контекст системы (RAG):
%s
""";

    /** Промпт для NarrativeWriterService.composeNarrative */
    private static final String NARRATIVE_WRITER_PROMPT = """
Ты — методолог процессов комплаенс и аналитик требований.
На основе описания задачи и цели сформируй подробный пользовательский нарратив для ICONIX-моделирования.

Важно про контекст системы (RAG):
- Если контекст системы указан и не равен «нет» — используй только термины, сущности, роли и функциональность из этого контекста.
- Если контекст системы отсутствует (указано «нет» или он пуст) — опирайся только на описание задачи и цель; не придумывай сущности, которых нет в задании: никаких товаров, проектов, каталогов, вымышленных ролей или экранов, если пользователь их не упомянул.

Структура ответа:
- 3–5 абзацев, каждый описывает последовательность действий пользователя и системные реакции.
- Упоминай только те роли, UI-экраны, интеграции и сущности, которые есть в контексте системы или явно в описании задачи/цели.
- Не углубляйся слишком в технику. Глоссарий — для бизнес-заказчика. Учитывай, что по этому нарративу будет строиться доменная модель.

Описание задачи:
%s

Бизнес-цель:
%s

Контекст системы (RAG):
%s

Выведи только текст нарратива без списков, заголовков и пояснений.
""";
}
